<!DOCTYPE html>

<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Smyth</title>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet"> 

    <!-- Smyth -->
    <script src="smyth.js"></script>

    <!-- Code Mirror -->
    <script src="codemirror/codemirror.js"></script>
    <link rel="stylesheet" href="codemirror/codemirror.css">
    <script src="codemirror/mode-custom-elm.js"></script>
    <link rel="stylesheet" href="codemirror/theme-base16-dark.css"></script>

    <!-- Main -->
    <link rel="stylesheet" href="reset.css" />
    <link rel="stylesheet" href="main.css" />
    <script src="main.js"></script>
  </head>
  <body>
    <header>
      <h1>
        <span class="system">Smyth</span>
      </h1>
      <ol class="authors">
        <li><a href="https://jlubin.net">Justin Lubin</a></li>
        <li><a href="https://orcid.org/0000-0001-6578-2005">Nick Collins</a></li>
        <li><a href="http://web.eecs.umich.edu/~comar/">Cyrus Omar</a></li>
        <li><a href="http://people.cs.uchicago.edu/~rchugh/">Ravi Chugh</a></li>
      </ol>
    </header>

    <section>
      <div>
        <p>
          <span class="system">Smyth</span> is a tool that completes unfinished
          programs in a typed, functional language by gathering information from
          normal code assertions.

        <p>
          Let&rsquo;s see how
          <span class="system">Smyth</span>
          can help us finish a program that duplicates each element of a list.
        </p>

        <p>
          We&rsquo;ve written out the types and some unit tests here, but the
          actual implementation is incomplete.
          Click the &ldquo;Forge&rdquo; button to have
          <span class="system">Smyth</span>
          forge some code for us.
        </p>

        <div class="nb">
          <h4>Try it yourself!</h4>
          <p>
            You can edit all this code in the browser! Just be warned: the
            web-based version of
            <span class="system">Smyth</span>
            is much slower and less robust than the
            <a href="https://github.com/UChicago-PL">official command-line tool</a>,
            so check that repo out if you want to try more involved
            examples.
          </p>
        </div>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)

stutter : NatList -> NatList
stutter xs =
  ??

assert stutter []     == []
assert stutter [1, 0] == [1, 1, 0, 0]</textarea>
        </div>

        <p>
          <span class="system">Smyth</span>
          gathers enough information from our assertions to fill in the hole on
          line 11 of our program.
        </p>

        <p>
          Let&rsquo;s take a look at a more complicated example.
        </p>
      </div>
    </section>

    <section>
      <div>
        <p>
          Let&rsquo;s create a function <code>max</code> that returns the
          greater of its two arguments.
        </p>

        <p>
          We&rsquo;ll use the <code>specifyFunction2</code> helper function
          that uses a list of input-output pairs to create assertions about its
          first argument.
        </p>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type Boolean = F () | T ()
type Cmp     = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

max : Nat -> Nat -> Nat
max m n =
  ??

specifyFunction2 max
  [ (0, 0, 0), (0, 1, 1), (0, 2, 2)
  , (1, 0, 1), (1, 1, 1), (1, 2, 2)
  , (2, 0, 2), (2, 1, 2), (2, 2, 2)
  ]</textarea>
        </div>

        <p>
          <span class="system">Smyth</span> successfully synthesizes
          <code>max</code>, but it took a lot of examples! It might even be
          easier to write the entire function ourselves than specify nine
          individual examples.
        </p>

        <p>
          Sometimes its easier to write code than examples. For example, the
          case when <code>m = 0</code> is really easy for us to figure out:
          <code>max(0, n) = n</code>, always!
        </p>

        <p>
          If we sketch out this branch of the code in <code>max</code>,
          <span class="system">Smyth</span>
          can fill in the rest of the code for us with fewer examples.
        </p>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type Boolean = F () | T ()
type Cmp     = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

max : Nat -> Nat -> Nat
max m n =
  case m of
    Z _ ->
      n

    S m_ ->
      ??

specifyFunction2 max
  -- [ (0, 0, 0), (0, 1, 1), (0, 2, 2)
  -- , (1, 0, 1), (1, 1, 1), (1, 2, 2)
  -- , (2, 0, 2), (2, 1, 2), (2, 2, 2)
  -- ]
  [ (1, 0, 1)
  , (1, 1, 1)
  , (1, 2, 2)
  , (2, 1, 2)
  ]</textarea>
        </div>
      </div>
    </section>

    <section>
      <div>
        <h2>Sketches</h2>

        <p>
          As in the <code>max</code> example, we can provide
          partially-completed programs (known as <i>sketches</i>) to
          <span class="system">Smyth</span> to be completed.
        </p>

        <p>
          Internally, <span class="system">Smyth</span> uses sketches to keep
          track of its progress as it builds a full solution for us.
        </p>

        <p>
          In order to forge code for us, <span class="system">Smyth</span>
          needs a way to <em>run</em> these sketches and a way to <em>check</em>
          them against our assertions.
        </p>
        <p>
          Let&rsquo;s take a look at how
          <span class="system">Smyth</span>
          runs and checks sketches using <i>live evaluation</i> and
          <i>live unevaluation</i> respectively.
        </p>
      </div>
    </section>

    <section class="eval">
      <div>
        <h3>Live Evaluation <span class="right-arrow"></span></h3>

        <p>
          <span class="system">Smyth</span>
          uses a technique called <i>live evaluation</i> invented by the folks
          behind the <a href="https://hazel.org/">Hazel</a> project to run
          sketches.
        </p>

        <p>
          Live evaluation works by running the code &ldquo;around&rdquo; a
          hole.
          For example,
          <code>1 + 2 + ??</code>
          live evaluates to
          <code>3 + ??</code>.
        </p>

        <p>
          Each hole in the output also keeps track of what all the variables in
          the program are equal to at the time of evaluation. So
        </p>

        <div class="display">
          <code>let x = 7 in 1 + 2 + ??</code>
        </div>

        <p>
          live evaluates to
          <code>3 + [x ↦ 7] ??</code>.
        </p>

        <p>
          These bindings are very important for
          <span class="system">Smyth</span>
          when it comes time to generate the new code that completes a
          sketch.
        </p>
      </div>
    </section>

    <section class="uneval">
      <div>
        <h3><span class="left-arrow"></span> Live Unevaluation</h3>

        <p>
          <span class="system">Smyth</span>
          uses an all-new technique we call <i>live unevaluation</i> to check
          sketches against assertions.
        </p>

        <p>
          Live unevaluation transfers assertions on code to constraints
          specifically on holes.
        </p>

        <p>
          For example,
          <code>(3, 4)</code>
          unevaluates onto
          <code>(??<sub class="hole">0</sub>, 4)</code>
          with the constraint
          <code>??<sub class="hole">0</sub> ⊧ 3</code>.
        </p>

        <p>
          In other words,
          <code>assert (??<sub class="hole">0</sub>, 4) == (3, 4)</code>
          produces the constraint
          <code>??<sub class="hole">0</sub> ⊧ 3</code>.
        </p>

        <p>
          As with live evaluation,
          <span class="system">Smyth</span>
          keeps track of what the variables in the program are equal to, so
        </p>

        <div class="display">
          <code>let y = 8 in assert (??<sub class="hole">0</sub>, 4) == (3, 4)</code>
        </div>

        <p>
          produces the constraint
          <code>[y ↦ 8] ??<sub class="hole">0</sub> ⊧ 3</code>.
        </p>
      </div>
    </section>

    <section class="bieval">
      <div>
        <h2><span class="right-arrow"></span>Live Bidirectional Evaluation<span class="left-arrow"></span></h2>

        <p>
          We call the combination of live evaluation and live unevaluation
          <i>live bidirectional evaluation</i>!
        </p>

        <p>
          Live bidirectional evaluation enables
          <span class="system">Smyth</span>
          to take sketches with assertions and produce constraints on holes.
        </p>

        <p>
          <span class="system">Smyth</span>
          then feeds these constraints into an augmented version of the
          <span class="system">
            <a href="https://www.cis.upenn.edu/~stevez/papers/OZ15.pdf">
              Myth</a></span>
          algorithm to generate code that satisfies the hole constraints.
        </p>

        <div class="nb">
          <h4>
            <span class="system">Smyth</span>
            vs.
            <span class="system">Myth</span>
          </h4>
          <p>
            The original
            <span class="system">Myth</span>
            algorithm only allows for independent top-level holes and requires
            that assertions be <i>trace-complete</i>. A set of assertions for a
            function is trace-complete if, when the function is called on each
            of the asserted examples, all its recursive calls <em>also</em> have
            an asserted example in the set.
          </p>

          <p>
            For example, a trace-complete version of the set of assertions for
            the <code>stutter</code> function given above would be:
          </p>

<code class="display">specifyFunction stutter
  [ ([], [])
  , ([0], [0, 0])
  , ([1, 0], [1, 1, 0, 0])
  ]</code>

          <p>
            (Notice the extra example for <code>[0]</code>.)
          </p>

          <p>
            The two main contributions of <span class="system">Smyth</span> that
            live bidirectional evaluation enables are thus:
          </p>

          <ol>
            <li>Synthesis of recursive functions without trace-complete sets of
              assertions; and</li>
            <li>Support for specifying and solve interdependent synthesis goals
              at arbitrary locations in the program.</li>
          </ol>
        </div>
      </div>
    </section>

    <section>
      <div>
        <h2>Some More Examples</h2>

        <p>
          Here are some more examples you can play with!
        </p>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)
type Cmp     = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

insert : NatList -> Nat -> NatList
insert xs n =
  case xs of
    Nil _ ->
      [n]

    Cons (head, tail) ->
      ??

specifyFunction2 insert
  [ ([1], 1, [1])
  , ([1], 2, [1, 2])
  , ([2], 0, [0, 2])
  , ([1, 2, 4], 3, [1, 2, 3, 4])
  ]</textarea>
        </div>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)
type Cmp = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

insert : NatList -> Nat -> NatList
insert xs n =
  case xs of
    Nil _ ->
      [n]
    Cons (head, tail) ->
      case compare n head of
        LT _ ->
          Cons (n, xs)
        EQ _ ->
          xs
        GT _ ->
          Cons (head, insert tail n)

sort : NatList -> NatList
sort xs =
  case xs of
    Nil _ ->
      []

    Cons (head, tail) ->
      ??

assert sort [5, 1, 6, 5] == [1, 5, 6]</textarea>
        </div>

        <div class="smyth">
<textarea>type Nat = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)

type NatTree
  = Leaf ()
  | Node (NatTree, Nat, NatTree)

append : NatList -> NatList -> NatList
append xs ys =
  case xs of
    Nil _ ->
      ys
    Cons (head, tail) ->
      Cons (head, append tail ys)

leaves : NatTree -> NatList
leaves tree =
  case tree of
    Leaf _ ->
      []

    Node (left, x, right) ->
      ??

specifyFunction leaves
  [ ( Node
        ( Node (Leaf (), 10, Leaf ())
        , 20
        , Leaf ()
        )
    , [10, 20]
    )
  , ( Node
        ( Leaf ()
        , 10
        , Node (Leaf (), 20, Leaf ())
        )
    , [10, 20]
    )
  ]</textarea>
        </div>
      </div>
    </section>

    <section>
      <div>
        <h2>More Information</h2>

        <p>
          Interested in <span class="interest">code</span>?
        </p>

        <p class="response">
          Check out TODO
        </p>

        <p>
          Interested in <span class="interest">theory</span>?
        </p>

        <p class="response">
          Check out TODO
        </p>

        <p>
          Interested in <span class="interest system">Myth</span>?
        </p>

        <p class="response">
          Check out TODO
        </p>
      </div>
    </section>
  </body>
</html>
