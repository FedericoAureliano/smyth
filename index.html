<!DOCTYPE html>

<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Smyth</title>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata&family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <!-- Smyth -->
    <script src="smyth.js"></script>

    <!-- Code Mirror -->
    <script src="codemirror/codemirror.js"></script>
    <link rel="stylesheet" href="codemirror/codemirror.css">
    <script src="codemirror/mode-custom-elm.js"></script>
    <link rel="stylesheet" href="codemirror/theme-base16-dark.css"></script>

    <!-- Main -->
    <link rel="stylesheet" href="reset.css" />
    <link rel="stylesheet" href="main.css" />
    <script src="main.js"></script>
  </head>
  <body>
    <header>
      <h1>
        <span class="system">Smyth</span>
      </h1>
      <ol class="authors">
        <li><a href="https://jlubin.net">Justin Lubin</a></li>
        <li><a href="https://orcid.org/0000-0001-6578-2005">Nick Collins</a></li>
        <li><a href="http://web.eecs.umich.edu/~comar/">Cyrus Omar</a></li>
        <li><a href="http://people.cs.uchicago.edu/~rchugh/">Ravi Chugh</a></li>
      </ol>
    </header>

    <section>
      <div>
        <p>
          <span class="system">Smyth</span> is a tool that completes unfinished
          programs in a typed, functional language by gathering information from
          normal code assertions. </p><p>Such a tool is known as a
          <i>program synthesizer</i>.
        </p>

        <p>
          Let&rsquo;s see how
          <span class="system">Smyth</span>
          can help us finish a program that duplicates each element of a list.
        </p>

        <div class="nb">
          <h4>Try it yourself!</h4>
          <p>
            You can edit all this code in the browser! Just be warned: the
            web-based version of
            <span class="system">Smyth</span>
            is much slower and less robust than the
            <a href="https://github.com/UChicago-PL/smyth">official command-line tool</a>,
            so check that repo out if you want to try more involved
            examples.
          </p>
        </div>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)

stutter : NatList -> NatList
stutter xs =
  ??

assert stutter []     == []
assert stutter [1, 0] == [1, 1, 0, 0]</textarea>
        </div>

        <p>
          We&rsquo;ve written out the types and some unit tests here, but the
          actual implementation is incomplete.
          Click the &ldquo;Forge&rdquo; button above to have
          <span class="system">Smyth</span>
          forge some code for us.
        </p>

        <p>
          <span class="system">Smyth</span>
          gathers enough information from our assertions to fill in the hole on
          line 11 of our program.
        </p>

        <p>
          Let&rsquo;s take a look at a more complicated example.
        </p>
      </div>
    </section>

    <section>
      <div>
        <p>
          Let&rsquo;s create a function <code>max</code> that returns the
          greater of its two arguments.
        </p>

        <div class="nb">
          <h4><code>specifyFunction</code></h4>
          <p>
            We&rsquo;ll often use the helper function <code>specifyFunction</code>
            as shorthand for a list of assertions. For example,
            <code>specifyFunction f [(0, 1), (2, 3)]</code> would yield the
            assertions <code>assert f 0 == 1</code> and <code>assert f 2 == 3</code>.
          </p>

          <p>
            We also define helpers <code>specifyFunction2</code>,
            <code>specifyFunction3</code>, and so on to specify two- and three-
            argument functions, respectively (and so on).
          </p>
        </div>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type Boolean = F () | T ()
type Cmp     = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

max : Nat -> Nat -> Nat
max m n =
  ??

specifyFunction2 max
  [ (0, 0, 0), (0, 1, 1), (0, 2, 2)
  , (1, 0, 1), (1, 1, 1), (1, 2, 2)
  , (2, 0, 2), (2, 1, 2), (2, 2, 2)
  ]</textarea>
        </div>

        <p>
          <span class="system">Smyth</span> successfully synthesizes
          <code>max</code>, but it took a lot of examples!
          Try removing some examples to see if and when
          <span class="system">Smyth</span>
          returns overspecialized code.
        </p>

        <p>
          The truth is, sometimes it&rsquo;s easier to write code than
          examples. For example, the case when <code>m = 0</code> is really
          easy for us to figure out: <code>max(0, n) = n</code>, always!
        </p>

        <p>
          If we sketch out this branch of the code in <code>max</code>,
          <span class="system">Smyth</span>
          can fill in the rest of the code for us with fewer examples.
        </p>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type Boolean = F () | T ()
type Cmp     = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

max : Nat -> Nat -> Nat
max m n =
  case m of
    Z _ ->
      n

    S m_ ->
      ??

specifyFunction2 max
  -- [ (0, 0, 0), (0, 1, 1), (0, 2, 2)
  -- , (1, 0, 1), (1, 1, 1), (1, 2, 2)
  -- , (2, 0, 2), (2, 1, 2), (2, 2, 2)
  -- ]
  [ (1, 0, 1)
  , (1, 1, 1)
  , (1, 2, 2)
  , (2, 1, 2)
  ]</textarea>
        </div>
      </div>
    </section>

    <section>
      <div>
        <h2>Sketches</h2>

        <p>
          As in the <code>max</code> example, we can provide
          partially-completed programs (known as <i>sketches</i>) to
          <span class="system">Smyth</span> to be completed.
        </p>

        <p>
          Internally, <span class="system">Smyth</span> uses sketches to keep
          track of its progress as it builds a full solution for us.
        </p>

        <p>
          In order to forge code for us, <span class="system">Smyth</span>
          needs a way to <em>run</em> these sketches and a way to <em>check</em>
          them against our assertions.
        </p>
        <p>
          Let&rsquo;s take a look at how
          <span class="system">Smyth</span>
          runs and checks sketches using <i>live evaluation</i> and
          <i>live unevaluation</i> respectively.
        </p>
      </div>
    </section>

    <section class="eval">
      <div>
        <h3>Live Evaluation <span class="right-arrow"></span></h3>

        <p>
          <span class="system">Smyth</span>
          uses a technique called <i>live evaluation</i> invented by the folks
          behind the <a href="https://hazel.org/">Hazel</a> project to run
          sketches.
        </p>

        <p>
          Live evaluation works by running the code &ldquo;around&rdquo; a
          hole.
          For example,
          <code>1 + 2 + ??</code>
          live evaluates to
          <code>3 + ??</code>.
        </p>

        <p>
          Each hole in the output also keeps track of what all the variables in
          the program are equal to at the time of evaluation. So
        </p>

        <div class="display">
          <code>let x = 7 in 1 + 2 + ??</code>
        </div>

        <p>
          live evaluates to
          <code>3 + [x ↦ 7] ??</code>.
        </p>

        <p>
          These bindings are very important for
          <span class="system">Smyth</span>
          when it comes time to generate the new code that completes a
          sketch.
        </p>
      </div>
    </section>

    <section class="uneval">
      <div>
        <h3><span class="left-arrow"></span> Live Unevaluation</h3>

        <p>
          <span class="system">Smyth</span>
          uses an all-new technique we call <i>live unevaluation</i> to check
          sketches against assertions.
        </p>

        <p>
          Live unevaluation transfers assertions on code to constraints
          specifically on holes.
        </p>

        <p>
          For example,
          <code>(3, 4)</code>
          unevaluates onto
          <code>(??<sub class="hole">0</sub>, 4)</code>
          with the constraint
          <code>??<sub class="hole">0</sub> ⊧ 3</code>.
        </p>

        <p>
          In other words,
          <code>assert (??<sub class="hole">0</sub>, 4) == (3, 4)</code>
          produces the constraint
          <code>??<sub class="hole">0</sub> ⊧ 3</code>.
        </p>

        <p>
          As with live evaluation,
          <span class="system">Smyth</span>
          keeps track of what the variables in the program are equal to, so
        </p>

        <div class="display">
          <code>let y = 8 in assert (??<sub class="hole">0</sub>, 4) == (3, 4)</code>
        </div>

        <p>
          produces the constraint
          <code>[y ↦ 8] ??<sub class="hole">0</sub> ⊧ 3</code>.
        </p>
      </div>
    </section>

    <section class="bieval">
      <div>
        <h2><span class="right-arrow"></span>Live Bidirectional Evaluation<span class="left-arrow"></span></h2>

        <p>
          We call the combination of live evaluation and live unevaluation
          <i>live bidirectional evaluation</i>!
        </p>

        <p>
          Live bidirectional evaluation enables
          <span class="system">Smyth</span>
          to take sketches with assertions and produce constraints on holes.
        </p>

        <p>
          <span class="system">Smyth</span>
          then feeds these constraints into an augmented version of the
          <span class="system">
            <a href="https://www.cis.upenn.edu/~stevez/papers/OZ15.pdf">
              Myth</a></span>
          algorithm to generate code that satisfies the hole constraints.
        </p>

        <div class="nb">
          <h4>
            <span class="system">Smyth</span>
            vs.
            <span class="system">Myth</span>
          </h4>
          <p>
            The original
            <span class="system">Myth</span>
            algorithm only allows for independent top-level holes and requires
            that assertions be <i>trace-complete</i>. A set of assertions for a
            function is trace-complete if, when the function is called on each
            of the asserted examples, all its recursive calls <em>also</em> have
            an asserted example in the set.
          </p>

          <p>
            For example, a trace-complete version of the set of assertions for
            the <code>stutter</code> function given above would be:
          </p>

<code class="display">specifyFunction stutter
  [ ([], [])
  , ([0], [0, 0])
  , ([1, 0], [1, 1, 0, 0])
  ]</code>

          <p>
            (Notice the extra example for <code>[0]</code>.)
          </p>

          <p>
            The two main contributions of <span class="system">Smyth</span> that
            live bidirectional evaluation enables are thus:
          </p>

          <ol>
            <li>Synthesis of recursive functions without trace-complete sets of
              assertions; and</li>
            <li>Support for specifying and solving interdependent synthesis
              goals at arbitrary locations in the program.</li>
          </ol>
        </div>
      </div>
    </section>

    <section>
      <div>
        <h2>More Examples</h2>

        <p>
          Let&rsquo;s start with a function that inserts a number into a sorted
          list:
        </p>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)
type Cmp     = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

insert : NatList -> Nat -> NatList
insert xs n =
  case xs of
    Nil _ ->
      [n]

    Cons (head, tail) ->
      ??

specifyFunction2 insert
  [ ([1], 1, [1])
  , ([1], 2, [1, 2])
  , ([2], 0, [0, 2])
  , ([1, 2, 4], 3, [1, 2, 3, 4])
  ]</textarea>
        </div>

        <p>
          Now let&rsquo;s use that function to make a sorting function:
        </p>

        <div class="smyth">
<textarea>type Nat     = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)
type Cmp = LT () | EQ () | GT ()

compare : Nat -> Nat -> Cmp
compare n1 n2 =
  case n1 of
    Z _ ->
      case n2 of
        Z _ -> EQ ()
        S _ -> LT ()
    S m1 ->
      case n2 of
        Z _  -> GT ()
        S m2 -> compare m1 m2

insert : NatList -> Nat -> NatList
insert xs n =
  case xs of
    Nil _ ->
      [n]
    Cons (head, tail) ->
      case compare n head of
        LT _ ->
          Cons (n, xs)
        EQ _ ->
          xs
        GT _ ->
          Cons (head, insert tail n)

sort : NatList -> NatList
sort xs =
  case xs of
    Nil _ ->
      []

    Cons (head, tail) ->
      ??

assert sort [5, 1, 6, 5] == [1, 5, 6]</textarea>
        </div>

        <p>
          Changing gears, we can also work with more complex data structures
          like trees. Let&rsquo;s make a function that returns an in-order
          traversal of a tree:
        </p>

        <div class="smyth">
<textarea>type Nat = Z () | S Nat
type NatList = Nil () | Cons (Nat, NatList)

type NatTree
  = Leaf ()
  | Node (NatTree, Nat, NatTree)

append : NatList -> NatList -> NatList
append xs ys =
  case xs of
    Nil _ ->
      ys
    Cons (head, tail) ->
      Cons (head, append tail ys)

leaves : NatTree -> NatList
leaves tree =
  case tree of
    Leaf _ ->
      []

    Node (left, x, right) ->
      ??

specifyFunction leaves
  [ ( Node
        ( Node (Leaf (), 10, Leaf ())
        , 20
        , Leaf ()
        )
    , [10, 20]
    )
  , ( Node
        ( Leaf ()
        , 10
        , Node (Leaf (), 20, Leaf ())
        )
    , [10, 20]
    )
  ]</textarea>
        </div>
      </div>
    </section>

    <section class="more-info">
      <div>
        <h2>More Information</h2>

        <p>
          Interested in <span class="interest">more examples</span>?
        </p>

        <div class="response">
          <p>
            Check out the <code>examples</code> directory in the
            <a href="https://github.com/UChicago-PL/smyth">
              <span class="system">Smyth</span> repository</a>.
            You&rsquo;ll need to use the command-line version of
              <span class="system">Smyth</span>
            to run some of those examples.
            (The repo&rsquo;s <code>README</code> contains installation
            instructions.)
          </p>
        </div>

        <p>
          Interested in <span class="system">Smyth</span>&rsquo;s
          <span class="interest">implementation</span>?
        </p>

        <div class="response">
          <p>
            Check out the
              <a href="https://github.com/UChicago-PL/smyth">
                <span class="system">Smyth</span> repository</a>,
            the
              <a href="docs">
                <span class="system">Smyth</span> code documentation</a>,
            and
              <a href="https://jlubin.net">
                Justin Lubin&rsquo;s</a>
              <a href="https://jlubin.net/assets/forging-smyth.pdf">
                undergraduate thesis</a>,
            which discusses implementation details of
            <span class="system">Smyth</span>.
          </p>
        </div>

        <p>
          Interested in <span class="interest">theory</span>?
        </p>

        <div class="response">
          <p>
            Check out our ICFP 2020 publication,
              <a href="https://arxiv.org/pdf/1911.00583.pdf">
                Program Sketching with Live Bidirectional Evaluation</a>.
          </p>
        </div>

        <p>
          Interested in <span class="interest system">Myth</span>?
        </p>

        <div class="response">
          <p>
            Check out
              <a href="https://iampmo.com/">
                Peter-Michael Osera&rsquo;s</a>
              <a href="https://iampmo.com/publications/osera-phd-thesis.pdf">
                PhD thesis</a>,
            which was a huge help in developing
            <span class="system">Smyth</span>!
          </p>
        </div>

        <p>
          Interested in <span class="interest system">live evaluation</span>?
        </p>

        <div class="response">
          <p>
            Check out the
              <a href="https://hazel.org/">
                Hazel</a>
            project, which pioneered live evaluation and takes related ideas
            even further. The Hazel team is actually working on implementing
            <span class="system">Smyth</span> within their system right now!
          </p>
        </div>
      </div>
    </section>

    <section>
      <div>
        <h2>Acknowledgements</h2>

        <p>
          We would like to thank:
        </p>
        <ul>
          <li>
            <a href="http://www.cs.cmu.edu/~iev/">
              Ian Voysey</a>
            for guidance regarding proof strategies;
          </li>
          <li>
            <a href="https://cseweb.ucsd.edu/~npolikarpova/">
              Nadia Polikarpova</a>,
            <a href="http://people.cs.uchicago.edu/~brianhempel/">
              Brian Hempel</a>,
            <a href="https://michaeldadams.org/">
              Michael Adams</a>,
            <a href="https://sites.google.com/site/youyoucong212/">
              Youyou Cong</a>, and
            anonymous reviewers for many helpful suggestions;
          </li>
          <li>
            <a href="http://pages.cs.wisc.edu/~aws/">
              Aws Albarghouthi</a>,
            <a href="https://people.csail.mit.edu/feser/">
              John Feser</a>,
            <a href="https://lara.epfl.ch/~kuncak/">
              Viktor Kunčak</a>, and
            <a href="https://cseweb.ucsd.edu/~npolikarpova/">
              Nadia Polikarpova</a>
            for answering questions about
            <span class="system">Escher</span>,
            <span class="lambda-system">λ<sup>2</sup></span>,
            <span class="system">Leon</span>, and
            <span class="system">Synquid</span>; and
          </li>
          <li>
            <a href="https://www.cs.umd.edu/~rrand/">
              Robert Rand</a>&mdash;who
            coined the name
            <span class="system">Myth</span>&mdash;for
            suggesting the name
            <span class="system">Smyth</span>, thus
            further entangling our work with its predecessor.
          </li>
        </ul>
        <p>
          This work was supported by the following
          <a href="https://www.nsf.gov/">
            NSF</a>
          grants:
        </p>
        <ul>
          <li>
            <em>Semantic Foundations for Hole-Driven Development</em>
            (<a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1814900">CCF-1814900</a>
            and
            <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1817145">CCF-1817145</a>);
            and
          </li>
          <li>
            <em>Direct Manipulation Programming Systems</em>
            (<a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1651794">CCF-1651794</a>).
          </li>
        </ul>
      </div>
    </section>
  </body>
</html>
