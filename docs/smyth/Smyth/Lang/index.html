<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lang (smyth.Smyth.Lang)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">smyth</a> &#x00BB; <a href="../index.html">Smyth</a> &#x00BB; Lang</nav><h1>Module <code>Smyth.Lang</code></h1></header><aside><p>The syntax of Core Smyth, as defined in <b>Figure 3</b> of the ICFP 2020 paper.</p></aside><dl><dt class="spec type" id="type-hole_name"><a href="#type-hole_name" class="anchor"></a><code><span class="keyword">type</span> hole_name</code><code> = int</code></dt><dd><p>The type of hole &quot;names,&quot; which is used to identify holes for synthesis.</p></dd></dl><dl><dt class="spec module" id="module-Hole_map"><a href="#module-Hole_map" class="anchor"></a><code><span class="keyword">module</span> <a href="Hole_map/index.html">Hole_map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A map with domain <a href="index.html#type-hole_name"><code>hole_name</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-hole_map"><a href="#type-hole_map" class="anchor"></a><code><span class="keyword">type</span> <span>'a hole_map</span></code><code> = <span><span class="type-var">'a</span> <a href="Hole_map/index.html#type-t">Hole_map.t</a></span></code></dt><dd><p>An abbreviation for using <a href="Hole_map/index.html"><code>Hole_map</code></a>s.</p></dd></dl><dl><dt class="spec type" id="type-typ"><a href="#type-typ" class="anchor"></a><code><span class="keyword">type</span> typ</code><code> = </code><table class="variant"><tr id="type-typ.TArr" class="anchored"><td class="def constructor"><a href="#type-typ.TArr" class="anchor"></a><code>| </code><code><span class="constructor">TArr</span> <span class="keyword">of</span> <a href="index.html#type-typ">typ</a> * <a href="index.html#type-typ">typ</a></code></td><td class="doc"><p>Arrow type</p></td></tr><tr id="type-typ.TTuple" class="anchored"><td class="def constructor"><a href="#type-typ.TTuple" class="anchor"></a><code>| </code><code><span class="constructor">TTuple</span> <span class="keyword">of</span> <span><a href="index.html#type-typ">typ</a> list</span></code></td><td class="doc"><p>Tuple type</p></td></tr><tr id="type-typ.TData" class="anchored"><td class="def constructor"><a href="#type-typ.TData" class="anchor"></a><code>| </code><code><span class="constructor">TData</span> <span class="keyword">of</span> string * <span><a href="index.html#type-typ">typ</a> list</span></code></td><td class="doc"><p>Datatype</p></td></tr><tr id="type-typ.TForall" class="anchored"><td class="def constructor"><a href="#type-typ.TForall" class="anchor"></a><code>| </code><code><span class="constructor">TForall</span> <span class="keyword">of</span> string * <a href="index.html#type-typ">typ</a></code></td><td class="doc"><p>Universal quantification</p></td></tr><tr id="type-typ.TVar" class="anchored"><td class="def constructor"><a href="#type-typ.TVar" class="anchor"></a><code>| </code><code><span class="constructor">TVar</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Type variable</p></td></tr></table></dt><dd><p>Expression types.</p></dd></dl><dl><dt class="spec type" id="type-pat"><a href="#type-pat" class="anchor"></a><code><span class="keyword">type</span> pat</code><code> = </code><table class="variant"><tr id="type-pat.PVar" class="anchored"><td class="def constructor"><a href="#type-pat.PVar" class="anchor"></a><code>| </code><code><span class="constructor">PVar</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Variable pattern</p></td></tr><tr id="type-pat.PTuple" class="anchored"><td class="def constructor"><a href="#type-pat.PTuple" class="anchor"></a><code>| </code><code><span class="constructor">PTuple</span> <span class="keyword">of</span> <span><a href="index.html#type-pat">pat</a> list</span></code></td><td class="doc"><p>Tuple pattern</p></td></tr><tr id="type-pat.PWildcard" class="anchored"><td class="def constructor"><a href="#type-pat.PWildcard" class="anchor"></a><code>| </code><code><span class="constructor">PWildcard</span></code></td><td class="doc"><p>Wildcard pattern</p></td></tr></table></dt><dd><p>Patterns.</p></dd></dl><dl><dt class="spec type" id="type-param"><a href="#type-param" class="anchor"></a><code><span class="keyword">type</span> param</code><code> = </code><table class="variant"><tr id="type-param.PatParam" class="anchored"><td class="def constructor"><a href="#type-param.PatParam" class="anchor"></a><code>| </code><code><span class="constructor">PatParam</span> <span class="keyword">of</span> <a href="index.html#type-pat">pat</a></code></td></tr><tr id="type-param.TypeParam" class="anchored"><td class="def constructor"><a href="#type-param.TypeParam" class="anchor"></a><code>| </code><code><span class="constructor">TypeParam</span> <span class="keyword">of</span> string</code></td></tr></table></dt><dd><p>The types of valid parameters in a function signature.</p></dd></dl><dl><dt class="spec type" id="type-exp_arg"><a href="#type-exp_arg" class="anchor"></a><code><span class="keyword">type</span> exp_arg</code><code> = </code><table class="variant"><tr id="type-exp_arg.EAExp" class="anchored"><td class="def constructor"><a href="#type-exp_arg.EAExp" class="anchor"></a><code>| </code><code><span class="constructor">EAExp</span> <span class="keyword">of</span> <a href="index.html#type-exp">exp</a></code></td></tr><tr id="type-exp_arg.EAType" class="anchored"><td class="def constructor"><a href="#type-exp_arg.EAType" class="anchor"></a><code>| </code><code><span class="constructor">EAType</span> <span class="keyword">of</span> <a href="index.html#type-typ">typ</a></code></td></tr></table></dt><dd><p>The types of valid arguments in a function application.</p></dd></dl><dl><dt class="spec type" id="type-exp"><a href="#type-exp" class="anchor"></a><code><span class="keyword">and</span> exp</code><code> = </code><table class="variant"><tr id="type-exp.EFix" class="anchored"><td class="def constructor"><a href="#type-exp.EFix" class="anchor"></a><code>| </code><code><span class="constructor">EFix</span> <span class="keyword">of</span> <span>string option</span> * <a href="index.html#type-param">param</a> * <a href="index.html#type-exp">exp</a></code></td><td class="doc"><p>Fix expressions <code>(name, param, body)</code></p></td></tr><tr id="type-exp.EApp" class="anchored"><td class="def constructor"><a href="#type-exp.EApp" class="anchor"></a><code>| </code><code><span class="constructor">EApp</span> <span class="keyword">of</span> bool * <a href="index.html#type-exp">exp</a> * <a href="index.html#type-exp_arg">exp_arg</a></code></td><td class="doc"><p>Applications <code>(special, head, arg)</code></p></td></tr><tr id="type-exp.EVar" class="anchored"><td class="def constructor"><a href="#type-exp.EVar" class="anchor"></a><code>| </code><code><span class="constructor">EVar</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Variables</p></td></tr><tr id="type-exp.ETuple" class="anchored"><td class="def constructor"><a href="#type-exp.ETuple" class="anchor"></a><code>| </code><code><span class="constructor">ETuple</span> <span class="keyword">of</span> <span><a href="index.html#type-exp">exp</a> list</span></code></td><td class="doc"><p>Tuples</p></td></tr><tr id="type-exp.EProj" class="anchored"><td class="def constructor"><a href="#type-exp.EProj" class="anchor"></a><code>| </code><code><span class="constructor">EProj</span> <span class="keyword">of</span> int * int * <a href="index.html#type-exp">exp</a></code></td><td class="doc"><p>Tuple projections <code>(n, i, arg)</code></p></td></tr><tr id="type-exp.ECtor" class="anchored"><td class="def constructor"><a href="#type-exp.ECtor" class="anchor"></a><code>| </code><code><span class="constructor">ECtor</span> <span class="keyword">of</span> string * <span><a href="index.html#type-typ">typ</a> list</span> * <a href="index.html#type-exp">exp</a></code></td><td class="doc"><p>Constructors <code>(name, type args, arg)</code></p></td></tr><tr id="type-exp.ECase" class="anchored"><td class="def constructor"><a href="#type-exp.ECase" class="anchor"></a><code>| </code><code><span class="constructor">ECase</span> <span class="keyword">of</span> <a href="index.html#type-exp">exp</a> * <span><span>(string * <span>(<a href="index.html#type-pat">pat</a> * <a href="index.html#type-exp">exp</a>)</span>)</span> list</span></code></td><td class="doc"><p>Case expressions <code>(scrutinee, branches)</code></p></td></tr><tr id="type-exp.EHole" class="anchored"><td class="def constructor"><a href="#type-exp.EHole" class="anchor"></a><code>| </code><code><span class="constructor">EHole</span> <span class="keyword">of</span> <a href="index.html#type-hole_name">hole_name</a></code></td><td class="doc"><p>Hole expressions</p></td></tr><tr id="type-exp.EAssert" class="anchored"><td class="def constructor"><a href="#type-exp.EAssert" class="anchor"></a><code>| </code><code><span class="constructor">EAssert</span> <span class="keyword">of</span> <a href="index.html#type-exp">exp</a> * <a href="index.html#type-exp">exp</a></code></td><td class="doc"><p>Assertions</p></td></tr><tr id="type-exp.ETypeAnnotation" class="anchored"><td class="def constructor"><a href="#type-exp.ETypeAnnotation" class="anchor"></a><code>| </code><code><span class="constructor">ETypeAnnotation</span> <span class="keyword">of</span> <a href="index.html#type-exp">exp</a> * <a href="index.html#type-typ">typ</a></code></td><td class="doc"><p>Type annotations</p></td></tr></table></dt><dd><p>Expressions.</p><ul><li>If the &quot;name&quot; field of a fix expression is <code>None</code>, then the fix is a non-recursive lambda.</li></ul><ul><li>A &quot;special&quot; application is one that has recursion generated by synthesis from <a href="../Term_gen/index.html"><code>Term_gen</code></a>. This feature is tracked only for end-user purposes; it can be used, for example, in a &quot;recursive window&quot; UI (that only displays recursive solutions) or in benchmarks for the &quot;Top-1R&quot; (etc.) experiments.</li></ul></dd></dl><dl><dt class="spec type" id="type-res_arg"><a href="#type-res_arg" class="anchor"></a><code><span class="keyword">type</span> res_arg</code><code> = </code><table class="variant"><tr id="type-res_arg.RARes" class="anchored"><td class="def constructor"><a href="#type-res_arg.RARes" class="anchor"></a><code>| </code><code><span class="constructor">RARes</span> <span class="keyword">of</span> <a href="index.html#type-res">res</a></code></td></tr><tr id="type-res_arg.RAType" class="anchored"><td class="def constructor"><a href="#type-res_arg.RAType" class="anchor"></a><code>| </code><code><span class="constructor">RAType</span> <span class="keyword">of</span> <a href="index.html#type-typ">typ</a></code></td></tr></table></dt><dd><p>The types of valid arguments in a result function application.</p></dd></dl><dl><dt class="spec type" id="type-res"><a href="#type-res" class="anchor"></a><code><span class="keyword">and</span> res</code><code> = </code><table class="variant"><tr id="type-res.RFix" class="anchored"><td class="def constructor"><a href="#type-res.RFix" class="anchor"></a><code>| </code><code><span class="constructor">RFix</span> <span class="keyword">of</span> <a href="index.html#type-env">env</a> * <span>string option</span> * <a href="index.html#type-param">param</a> * <a href="index.html#type-exp">exp</a></code></td><td class="doc"><p>Fix closures</p></td></tr><tr id="type-res.RTuple" class="anchored"><td class="def constructor"><a href="#type-res.RTuple" class="anchor"></a><code>| </code><code><span class="constructor">RTuple</span> <span class="keyword">of</span> <span><a href="index.html#type-res">res</a> list</span></code></td><td class="doc"><p>Tuples</p></td></tr><tr id="type-res.RCtor" class="anchored"><td class="def constructor"><a href="#type-res.RCtor" class="anchor"></a><code>| </code><code><span class="constructor">RCtor</span> <span class="keyword">of</span> string * <a href="index.html#type-res">res</a></code></td><td class="doc"><p>Constructors</p></td></tr><tr id="type-res.RHole" class="anchored"><td class="def constructor"><a href="#type-res.RHole" class="anchor"></a><code>| </code><code><span class="constructor">RHole</span> <span class="keyword">of</span> <a href="index.html#type-env">env</a> * <a href="index.html#type-hole_name">hole_name</a></code></td><td class="doc"><p>Hole closures</p></td></tr><tr id="type-res.RApp" class="anchored"><td class="def constructor"><a href="#type-res.RApp" class="anchor"></a><code>| </code><code><span class="constructor">RApp</span> <span class="keyword">of</span> <a href="index.html#type-res">res</a> * <a href="index.html#type-res_arg">res_arg</a></code></td><td class="doc"><p>Applications</p></td></tr><tr id="type-res.RProj" class="anchored"><td class="def constructor"><a href="#type-res.RProj" class="anchor"></a><code>| </code><code><span class="constructor">RProj</span> <span class="keyword">of</span> int * int * <a href="index.html#type-res">res</a></code></td><td class="doc"><p>Tuple projections</p></td></tr><tr id="type-res.RCase" class="anchored"><td class="def constructor"><a href="#type-res.RCase" class="anchor"></a><code>| </code><code><span class="constructor">RCase</span> <span class="keyword">of</span> <a href="index.html#type-env">env</a> * <a href="index.html#type-res">res</a> * <span><span>(string * <span>(<a href="index.html#type-pat">pat</a> * <a href="index.html#type-exp">exp</a>)</span>)</span> list</span></code></td><td class="doc"><p>Case results</p></td></tr><tr id="type-res.RCtorInverse" class="anchored"><td class="def constructor"><a href="#type-res.RCtorInverse" class="anchor"></a><code>| </code><code><span class="constructor">RCtorInverse</span> <span class="keyword">of</span> string * <a href="index.html#type-res">res</a></code></td><td class="doc"><p>Inverse constructors</p></td></tr></table></dt><dd><p>Results.</p><ul><li>Determinate results: <code>RFix, RTuple, RCtor</code>.</li><li>Indeterminate results: <code>RHole, RApp, RProj, RCase, RCtorInverse</code>.</li></ul></dd></dl><dl><dt class="spec type" id="type-env"><a href="#type-env" class="anchor"></a><code><span class="keyword">and</span> env</code><code> = <span><span>(string * <a href="index.html#type-res">res</a>)</span> list</span> * <span><span>(string * <a href="index.html#type-typ">typ</a>)</span> list</span></code></dt><dd><p>Environments: <code>(result bindings, type variable bindings)</code>.</p></dd></dl><dl><dt class="spec type" id="type-bind_spec"><a href="#type-bind_spec" class="anchor"></a><code><span class="keyword">type</span> bind_spec</code><code> = </code><table class="variant"><tr id="type-bind_spec.NoSpec" class="anchored"><td class="def constructor"><a href="#type-bind_spec.NoSpec" class="anchor"></a><code>| </code><code><span class="constructor">NoSpec</span></code></td></tr><tr id="type-bind_spec.Rec" class="anchored"><td class="def constructor"><a href="#type-bind_spec.Rec" class="anchor"></a><code>| </code><code><span class="constructor">Rec</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-bind_spec.Arg" class="anchored"><td class="def constructor"><a href="#type-bind_spec.Arg" class="anchor"></a><code>| </code><code><span class="constructor">Arg</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-bind_spec.Dec" class="anchored"><td class="def constructor"><a href="#type-bind_spec.Dec" class="anchor"></a><code>| </code><code><span class="constructor">Dec</span> <span class="keyword">of</span> string</code></td></tr></table></dt><dd><p>Binding specifications.</p></dd></dl><dl><dt class="spec type" id="type-type_binding"><a href="#type-type_binding" class="anchor"></a><code><span class="keyword">type</span> type_binding</code><code> = string * <span>(<a href="index.html#type-typ">typ</a> * <a href="index.html#type-bind_spec">bind_spec</a>)</span></code></dt><dd><p>Type bindings for type contexts.</p></dd></dl><dl><dt class="spec type" id="type-poly_binding"><a href="#type-poly_binding" class="anchor"></a><code><span class="keyword">type</span> poly_binding</code><code> = string</code></dt><dd><p>Polymorphic name &quot;bindings&quot; for type contexts (just the name of the variable is needed in the type context).</p></dd></dl><dl><dt class="spec type" id="type-type_ctx"><a href="#type-type_ctx" class="anchor"></a><code><span class="keyword">type</span> type_ctx</code><code> = <span><a href="index.html#type-type_binding">type_binding</a> list</span> * <span><a href="index.html#type-poly_binding">poly_binding</a> list</span></code></dt><dd><p>Type contexts.</p></dd></dl><dl><dt class="spec type" id="type-datatype_ctx"><a href="#type-datatype_ctx" class="anchor"></a><code><span class="keyword">type</span> datatype_ctx</code><code> = <span><span>(string * <span>(<span>string list</span> * <span><span>(string * <a href="index.html#type-typ">typ</a>)</span> list</span>)</span>)</span> list</span></code></dt><dd><p>Datatype contexts.</p></dd></dl><dl><dt class="spec type" id="type-hole_ctx"><a href="#type-hole_ctx" class="anchor"></a><code><span class="keyword">type</span> hole_ctx</code><code> = <span><span>(<a href="index.html#type-hole_name">hole_name</a> * <span>(<a href="index.html#type-type_ctx">type_ctx</a> * <a href="index.html#type-typ">typ</a> * <span>string option</span> * int)</span>)</span> list</span></code></dt><dd><p>Hole contexts: <code>(hole name, type context, typ, decrease requirement, match depth)</code>. The &quot;decrease requirement&quot;, if present, is a function that expressions must be decreasing on to fill the hole in question.</p></dd></dl><dl><dt class="spec type" id="type-value"><a href="#type-value" class="anchor"></a><code><span class="keyword">type</span> value</code><code> = </code><table class="variant"><tr id="type-value.VTuple" class="anchored"><td class="def constructor"><a href="#type-value.VTuple" class="anchor"></a><code>| </code><code><span class="constructor">VTuple</span> <span class="keyword">of</span> <span><a href="index.html#type-value">value</a> list</span></code></td><td class="doc"><p>Tuples</p></td></tr><tr id="type-value.VCtor" class="anchored"><td class="def constructor"><a href="#type-value.VCtor" class="anchor"></a><code>| </code><code><span class="constructor">VCtor</span> <span class="keyword">of</span> string * <a href="index.html#type-value">value</a></code></td><td class="doc"><p>Constructors</p></td></tr></table></dt><dd><p>&quot;Simple&quot; values.</p></dd></dl><dl><dt class="spec type" id="type-example"><a href="#type-example" class="anchor"></a><code><span class="keyword">type</span> example</code><code> = </code><table class="variant"><tr id="type-example.ExTuple" class="anchored"><td class="def constructor"><a href="#type-example.ExTuple" class="anchor"></a><code>| </code><code><span class="constructor">ExTuple</span> <span class="keyword">of</span> <span><a href="index.html#type-example">example</a> list</span></code></td><td class="doc"><p>Tuples</p></td></tr><tr id="type-example.ExCtor" class="anchored"><td class="def constructor"><a href="#type-example.ExCtor" class="anchor"></a><code>| </code><code><span class="constructor">ExCtor</span> <span class="keyword">of</span> string * <a href="index.html#type-example">example</a></code></td><td class="doc"><p>Constructors</p></td></tr><tr id="type-example.ExInputOutput" class="anchored"><td class="def constructor"><a href="#type-example.ExInputOutput" class="anchor"></a><code>| </code><code><span class="constructor">ExInputOutput</span> <span class="keyword">of</span> <a href="index.html#type-value">value</a> * <a href="index.html#type-example">example</a></code></td><td class="doc"><p>Input-output examples</p></td></tr><tr id="type-example.ExTop" class="anchored"><td class="def constructor"><a href="#type-example.ExTop" class="anchor"></a><code>| </code><code><span class="constructor">ExTop</span></code></td><td class="doc"><p>Top (wildcard) examples</p></td></tr></table></dt><dd><p>Examples.</p></dd></dl><dl><dt class="spec type" id="type-world"><a href="#type-world" class="anchor"></a><code><span class="keyword">type</span> world</code><code> = <a href="index.html#type-env">env</a> * <a href="index.html#type-example">example</a></code></dt><dd><p>Example constraints, also known as &quot;worlds.&quot;</p></dd></dl><dl><dt class="spec type" id="type-worlds"><a href="#type-worlds" class="anchor"></a><code><span class="keyword">type</span> worlds</code><code> = <span><a href="index.html#type-world">world</a> list</span></code></dt><dd><p>Multiple example constraints (worlds).</p></dd></dl><dl><dt class="spec type" id="type-hole_filling"><a href="#type-hole_filling" class="anchor"></a><code><span class="keyword">type</span> hole_filling</code><code> = <span><a href="index.html#type-exp">exp</a> <a href="index.html#type-hole_map">hole_map</a></span></code></dt><dd><p>Hole fillings.</p></dd></dl><dl><dt class="spec type" id="type-unsolved_constraints"><a href="#type-unsolved_constraints" class="anchor"></a><code><span class="keyword">type</span> unsolved_constraints</code><code> = <span><a href="index.html#type-worlds">worlds</a> <a href="index.html#type-hole_map">hole_map</a></span></code></dt><dd><p>Unfilled holes, also known as &quot;unsolved constraints.&quot;</p></dd></dl><dl><dt class="spec type" id="type-constraints"><a href="#type-constraints" class="anchor"></a><code><span class="keyword">type</span> constraints</code><code> = <a href="index.html#type-hole_filling">hole_filling</a> * <a href="index.html#type-unsolved_constraints">unsolved_constraints</a></code></dt><dd><p>Constraints.</p></dd></dl><dl><dt class="spec type" id="type-resumption_assertion"><a href="#type-resumption_assertion" class="anchor"></a><code><span class="keyword">type</span> resumption_assertion</code><code> = <a href="index.html#type-res">res</a> * <a href="index.html#type-value">value</a></code></dt><dd><p>Resumption assertions, as defined in <b>Figure 7</b>.</p></dd></dl><dl><dt class="spec type" id="type-resumption_assertions"><a href="#type-resumption_assertions" class="anchor"></a><code><span class="keyword">type</span> resumption_assertions</code><code> = <span><a href="index.html#type-resumption_assertion">resumption_assertion</a> list</span></code></dt><dd><p>Multiple resumption assertions.</p></dd></dl><dl><dt class="spec type" id="type-gen_goal"><a href="#type-gen_goal" class="anchor"></a><code><span class="keyword">type</span> gen_goal</code><code> = <a href="index.html#type-type_ctx">type_ctx</a> * <a href="index.html#type-typ">typ</a> * <span>string option</span></code></dt><dd><p>Term generation (&quot;guessing&quot;) goals.</p></dd></dl><dl><dt class="spec type" id="type-synthesis_goal"><a href="#type-synthesis_goal" class="anchor"></a><code><span class="keyword">type</span> synthesis_goal</code><code> = <a href="index.html#type-gen_goal">gen_goal</a> * <a href="index.html#type-worlds">worlds</a></code></dt><dd><p>Basic synthesis goals.</p></dd></dl><dl><dt class="spec type" id="type-fill_goal"><a href="#type-fill_goal" class="anchor"></a><code><span class="keyword">type</span> fill_goal</code><code> = <a href="index.html#type-hole_name">hole_name</a> * <a href="index.html#type-synthesis_goal">synthesis_goal</a></code></dt><dd><p>Full notion of synthesis goals, including a hole name.</p></dd></dl><dl><dt class="spec type" id="type-synthesis_params"><a href="#type-synthesis_params" class="anchor"></a><code><span class="keyword">type</span> synthesis_params</code><code> = </code><code>{</code><table class="record"><tr id="type-synthesis_params.max_scrutinee_size" class="anchored"><td class="def field"><a href="#type-synthesis_params.max_scrutinee_size" class="anchor"></a><code>max_scrutinee_size : int;</code></td></tr><tr id="type-synthesis_params.max_match_depth" class="anchored"><td class="def field"><a href="#type-synthesis_params.max_match_depth" class="anchor"></a><code>max_match_depth : int;</code></td></tr><tr id="type-synthesis_params.max_term_size" class="anchored"><td class="def field"><a href="#type-synthesis_params.max_term_size" class="anchor"></a><code>max_term_size : int;</code></td></tr></table><code>}</code></dt><dd><p>Parameters for synthesis.</p></dd></dl></div></body></html>